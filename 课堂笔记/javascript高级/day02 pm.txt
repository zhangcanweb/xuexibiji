正课:
1. ***数组:
2. ***String:
  
1. ****排序:
  手写排序算法: 冒泡，插入，快速
  排序API:
    arr.sort(): 默认将所有元素转为字符串再排列。
    问题: 只能排列字符串类型的元素
    解决: 使用自定义比较器函数
     比较器函数: 专门比较任意两个数大小的函数
          要求: 两个参数: a,b
               返回值: a>b，就返回一个正数
                       a<b, 就返回一个负数
                               否则就返回0
     比如:专门比较两个数字的比较器: 
            function compare(a,b){return a-b;}
     何时使用: 只要sort默认的排序规则不是想要的
               就要自定义比较器函数，代替默认规则
     如何使用: 将比较器函数作为参数传入sort方法中
            arr.sort(compare);
       强调: 传入sort方法内的比较器函数属于回调函数
         回调函数: 将一个函数作为参数传入另一个函数中被反复调用
         传入回调函数时，不要加()!
   
    降序: 颠倒比较器函数的正负号
      比如: function compare(a,b){return b-a;}

2. 栈和队列: js中没有专门的栈和队列类型，都是用数组模拟的
栈: 一端封闭，只能从一端进出的数组
特点: FILO
何时: 希望始终使用最新的元素时，就用栈结构
如何: 
  1. 结尾出入栈: 
    入栈: arr.push(值) ==> arr[arr.length]=值
    出栈: var last=arr.pop()
    特点: 每次出入栈都不影响现有元素的位置
  2. 开头出入栈: 
    入栈: arr.unshift(值)
    出栈: var first=arr.shift();
    特点: 每次出入栈都会导致现有元素的位置发生顺移

队列: 只能从一端进入，从另一端出的数组
特点: FIFO
何时: 只要希望按照先来后到的顺序使用数组元素时
如何:
  结尾入: arr.push(值)
  开头出: var first=arr.shift();

3. 二维数组:
 什么是: 数组中的元素又引用了另一个子数组
 何时: 
   1. 如果要存储横行竖列的二维数据时
   2. 如果要对数组中存储的数据再进行细致分类时
 如何: 
   创建: 2种:
     1. 先创建空数组，再向空数组中添加子数组
	var data=[];
        data[0]=[2,2,4,0];
        data[1]=[2,0,2,2];
     2. 在创建数组同时，初始化子数组
	var data=[
       	  [2,2,4,0],
          [2,0,2,2],
        ];

   访问二维数组中的元素: arr[r][c]
    强调: 二维数组行下标不能越界: 会报错

   二维数组的length属性: 仅表示子数组的个数
 
   遍历二维数组: 外层循环遍历行，内层循环遍历列
     for(var r=0;r<arr.length;r++){
	for(var c=0;c<arr[r].length;c++){
	   arr[r][c]//当前元素
        }
     } 

2. String: 其实就是一串字符组成的只读数组
   vs 数组: 1. 下标
            2. length
            3. slice,concat
 













