正课:
1. ***String
  StringAPI
2. *****正则表达式

StringAPI:
1. 检索关键词:
  4种: 
   1. 查找一个固定关键词的出现位置:
     var i=str.indexOf("关键词",fromi);
     在str中从fromi位置开始查找下一个"关键词"所在的下标位置。
     强调: 1. 返回下标位置，如果找不到，返回-1
           2. 省略fromi，默认从0开始找
     固定套路: 查找所有关键词的位置:
       while((i=str.indexOf("关键词",i+1))!=-1){
         i //本次找到的关键词位置
       }

     var i=str.lastIndexOf("关键词",fromi);
     在str中从fromi位置开始查找前一个"关键词"所在的下标位置。
     强调: 省略fromi，默认从最后(length-1)位置开始找
     何时: 专门用于检索最后一个关键词的位置时

   问题: 只能查找一个固定的关键词
   解决: 用模式匹配――正则表达式
   2.仅判断是否包含符合规则的关键词: 
    var i=str.search(/正则表达式/)
      查找str中第一个符合正则表达式要求的关键词的位置i
      如果没找到，返回-1
     vs indexOf: 
      相同: 默认都是从0位置开始找第一个关键词的位置
            如果找不到，都返回-1
      不同: 
        indexOf: 优: 可指定开始位置！可查找所有
                 缺: 不支持模式匹配,每次只能找一个关键词
                 
        search: 缺: 不可指定开始位置，永远从0开始找
                优: 支持模式匹配
   3.列举所有关键词的内容: 
     var kwords=str.match(/正则表达式/g);
     检索出str中所有和正则表达式匹配的关键词
     返回值是包含所有关键词内容的数组
       如果没找到，返回null
     其中: g 表示查找所有，必须加
          为什么: 正则默认仅匹配第一个关键词
     优: 获得所有关键词的内容
     缺: 无法获得每个关键词的位置
   4.即获得每个关键词的内容，又获得每个关键词的位置:
     RegExp对象?
  
2. 替换

*****正则表达式: 
  什么是: 规定一个字符串中字符出现规律的表达式
  为什么: 现实中很多关键词的格式和内容都是有规律的，但又是不一样的。
  何时: 1. 按规则，模式匹配多个关键词――检索
        2. 按规则，检查一个字符串的格式――验证
  如何: 
    1. 最简单的正则就是关键词原文
    2. 字符集: 规定一位字符可用的备选字符列表
       何时: 如果关键词的某一位字符有多种备选时
       如何: [备选字符列表]
       强调: 一个字符集[]，只能且必须匹配一位字符
       简写: 如果字符集中的字符部分连续,可用-省略中间的
字符
        比如: 一位数字: [0-9]              
              一位小写字母: [a-z]
              一位大写字母: [A-Z]
              一位字母: [A-Za-z]

              一位汉字: [\u4e00-\u9fa5]

       除了...: [^47] 除了4和7之外都行！
             强调: ^必须放在[]内部的开头！

    3. 预定义字符集: 对常用字符集的最简化写法:
        一位数字: \d
        一位字母,数字或下划线: \w -> [A-Za-z0-9_]
        一位空字符: \s 包括: 空格，制表符

        通配符: 匹配任意字符: .

       强调: 只有在规则完全匹配时，才使用预定义字符集
             只要有一点不匹配，都要手动编写普通字符集
    4. 量词: 规定一个字符集出现次数的规则
       何时: 只要规定一个字符集出现的次数
       强调: 两次都要在字符集之后
       有明确边界:
         字符集{n,m} 至少n个，最多m个
         字符集{n,}  至少n个，多了不限
	 字符集{n}   必须n个
       没有明确边界: 
         字符集?     可有可无，最多1个
         字符集+     至少一个，多了不限
         字符集*     可有可无，多了不限――不限制个数

    5. 选择和分组
       分组: ()将多个字符集包裹为一组
         为什么: 量词默认仅修饰相邻的前一个字符集
         何时: 希望量词同时修饰多个字符集时，就要用()将多个字符集分为一组，用量词修饰分组。
       选择: 或者  规则1|规则2 只要满足任意一个规则即可

     比如: 滴滴出行: 防 微信 weixin wx
       (微|w(ei)?)\s*(信|x(in)?)

     比如: 手机号:
       +86或0086  可有可无，最多1个
       空字符 可有可无，多了不限
       1
       34578中选一个
       9位数字
     (\+86|0086)?\s*1[34578]\d{9}

   6.指定匹配位置:
     ^ 字符串开头: 比如: 开头的空字符: ^\s+
       何时: 仅匹配开头位置的xxx
     $ 字符串结尾: 比如: 结尾的空字符: \s+$
       何时: 仅匹配结尾位置的xxx
         同时匹配开头或结尾的空字符: ^\s+|\s+$
     \b 单词边界: 字符串开头 字符串结尾 空字符 标点...
       何时: 匹配单个单词时

   7.密码强度: 6~8位 字母，数字的组合，至少包含一个大写字母和一个数字
    预判: (?!规则$) 如果从头到尾不符合规则的要求
     1.排除: 不全由小写字母和数字组成
         说明: 可能有大写字母或特殊字符
       (?![a-z0-9]+$)
     2.排除: 不全由字母组成
         说明: 可能有数字或特殊字符
       (?![A-Za-z]+$)
     3.只能由字母和数字组成   
       [A-Za-z0-9]{6,8}
    最终: (?![a-z0-9]+$)(?![A-Za-z]+$)[A-Za-z0-9]{6,8}







