正课:
1. *****OOP
    封装
    继承

1. 封装: 创建对象: 3种: 
   1. 对象直接量: 
       var obj={
    
          属性名:属性值,
         
                ...  :  ... ,
    
          方法名: function(){

  
             ...this.属性名...
          }

       }
   问题: 对象自己的方法，如何访问当前对象自己的属性呢？
   错误: 直接写属性名: 报错: 变量名未定义
   解决: 任何对象自己的方法，想使用自己的属性，都必须:
              this.属性名   其中: this.翻译为: 当前对象的xxx
*****this: 在方法调用时，自动获得正在调用方法的.前的对象
     比如: lilei.intr() :  intr中的this->lilei
     原理: this在函数调用时，自动存储在函数作用域对象(AO)中
              被自动设置为引用当前函数.前的对象
     方法中: 不加this.的变量，默认仅在作用域链中找
                 加this.的属性，被引导到当前对象中找属性，不再查找作用域链。

   2. 用new: 2步: 
       var obj=new Object();  new可省, ()可省, 不能同时省略
       obj.属性名=属性值;
       obj.方法名=function(){ ...this.属性名... };
       何时: 在创建对象时，暂时不知道对象的成员

   揭示: js中一切对象底层都是关联数组
             对象的属性名其实是关联数组的key
             对象的属性值其实是关联数组的value
      后果: 对象的成员: 对象["属性名"]
                     对象.属性名 <==> 对象["属性名"]
                     对象.key                 对象["key"]
               对象可随时添加新属性
               用for in遍历对象的每个属性

  问题: 以上两种方法只适合创建一个对象
          如果反复创建多个相同结构，但值不同个对象，会导致大量重复代码！
  解决: 先定义对象的结构，再用相同结构反复创建对象
  3. 构造函数(constructor): 
     什么是构造函数: 描述一类对象统一结构的特殊函数
     何时: 只要反复创建多个结构相同，但值不同的一类对象时，都要先定义构造函数，再用构造函数反复创建对象
     如何: 2步:
        1. 定义构造函数: 
            function 类型名(属性参数){
	this.属性名=属性参数;//向新对象中添加新属性
                 this.方法名=function(){//向新对象中添加新方法
  	     ... this.属性名 ...
                 }
            }
        2. 用new调用构造函数，传入属性值作为参数，获得新对象
           var obj=new 类型名(属性值);

     new: 4件事: 
       1. 创建空对象: new Object()
       2. 让新对象继承构造函数的prototype
       3. 用新对象调用构造函数: 将构造函数中的this自动换成新对象
           
       4. 返回新对象的地址
   优: 代码重用！
   问题: 对象的方法被反复创建了多次，缺: 浪费内存
   解决: 继承: 

2. 继承: 
  什么是: 父对象中的成员，子对象不必反复创建，可直接使用   
  为什么: 即代码重用，又节约内存
  何时: 只要多个子对象，希望拥有相同的成员时
           就要将相同的成员集中保存在父对象中一份即可！
  如何: 
    原型对象(prototype): 集中存储一类子对象共有成员的父对象
    访问原型对象: 
        定义构造函数时，都会自动定义一个该构造函数的原型对象。
        构造函数中有一个prototype属性指向当前类型的原型对象
    向原型对象中添加共有成员:
        构造函数.prototype.方法=function(){ ... }









