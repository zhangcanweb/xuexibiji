正课:
1. *****OOP
   封装
   继承
   多态

面向对象三大特点: 封装，继承，多态
   封装: 将一个事物的属性和功能集中定义在一个对象中
   继承: 父对象中的成员，子对象可以直接访问
   多态: 同一个事物，在不同情况下表现出不同的状态

继承: 
  js中的继承，都是通过原型对象实现的
  原型对象: 集中存储一类对象的共有成员的父对象
     访问: 构造函数.prototype
     向原型对象中添加成员: 构造函数.prototype.成员=function
     构造函数创建出的子对象，都有__proto__属性继承构造函数的原型对象prototype
  
   自有属性和共有属性: 
   自有属性: 直接保存在子对象本地的属性都是自有属性
   共有属性: 保存在父级原型对象中，被所有子对象共用的属性
   为对象扩展属性: 
      为单个对象扩展自有属性: 对象.属性名=值
      为一类对象扩展共有属性: 构造函数.prototype.属性名=值
   修改属性: 
      修改自有属性: 对象.属性名=值
      修改共有属性: 必须用 构造函数.prototype.属性名=值
   删除属性: 
      删除自有属性: delete 对象.属性名;
      删除共有属性: 必须用 delete 构造函数.prototype.属性名
   判断自有还是共有: 
      判断自有属性: var bool=obj.hasOwnProperty("属性名")
           判断obj的本地是否包含自有属性"属性名"
      判断共有属性: !obj.hasOwnProperty("属性名")
                             &&obj.属性名!==undefined

   内置对象的原型对象: 
       new Array()  String()  RegExp()  Date() 
               Error() Function()  Object()
               一切都是构造函数
       每个类型都对应自己的prototype对象
       prototype对象中集中存储着该类型可用的所有API
   
   原型链(prototype chain): 由各级父元素连续继承，形成的链式结构。
     控制着: 对象.属性的使用顺序
            先用自有的，如果没有，才沿原型链向上找
     vs 作用域链: 控制着不带.的普通变量的使用范围
               先用局部，再用全局

   鄙视题: 判断一个对象是不是数组类型: 共几种方法
       错误: typeof()――只能区分原始类型和function，无法区分内置对象类型
       解决: 
        1. 判断原型对象: var bool=father.isPrototypeOf(child)
              判断father是不是child的父对象
        2. 判断构造函数: 
               var bool=child instanceof 构造函数
                 判断child是不是用指定的构造函数创建出来的
           instance: 实例: 用构造函数创建出的一个子对象
           实例化: 用new调用构造函数创建一个对象
        问题: 前两个检查不仅检查直接父对象，而且还检查整个原型链。
        解决: 
        3. 检查对象的class属性:  和原型链无关
            每个对象中都有一个内部属性class: 记录了对象创建时的类型。一旦创建，不会更改。
            问题1: class不允许用.直接访问
            解决: obj.toString() -> "[object class]"
                其中class可能为: Object Array Date ...
            问题2: 多数内置对象重写了toString方法
                       重写的toString方法已经无法返回class
            解决: 临时借用函数:
               函数.call(对象)  -> 对象.函数()
               Object.prototype.toString.call(obj1)
                                        -> obj1.toString();
      4. ES5 : Array.isArray(obj)

多态: 同一个方法在不同情况下表现出不同状态
   重写: 子对象觉得父对象的成员不好用
           可在本地定义同名自有属性，覆盖父对象成员
            使用时，优先使用子对象的成员。
   为什么:  体现子对象和父对象之间的差异

自定义继承: 
1. 修改子对象的__proto__指向指定的父对象: 
      child.__proto__=father;
      问题: __proto__是内部属性，可能被禁用: 
      解决: 获得父对象: Object.getPrototypeOf(child)
                                  获得child的原型父对象
               设置父对象: Object.setPrototypeOf(child, father)
                                  设置child继承father
   何时: 如果只修改两个对象间的继承

2. 通过修改构造函数的prototype属性，同时修改所有子对象的父对象: 
    构造函数.prototype=father
    强调: 时机: 一定要在开始创建对象前就换

3. 两种类型间的继承: 
   何时: 只要发现两个类型间，拥有相同的属性结构和方法定义
   如何: 
      1. 定义抽象父类型，保存子类型共有的属性结构和方法定义
             父类型的构造函数中保存： 共有的属性结构
             父类型的原型对象中保存 :  共有的方法定义
      2. 在子类型构造函数中调用父类型构造函数
          问题: 不能直接调用
                    如果直接调用父类型构造函数中的this->window
          解决: call: 2功能: 1. 借用本来不能调动的函数
                                     2. 替换函数中的this为想要的对象
      3. 让子类型原型对象，继承父类型原型对象









