正课:
1. ***Error
2. *****Function

1. ***Error: 
   错误: 在程序执行过程中，导致程序异常中断的特殊情况
   错误处理: 在程序执行过程中，即使程序出错，也能保证不会异常中断的机制。
   如何: 
      try{
          可能出现错误的语句
      }catch(err){//err: 自动获得错误对象――不可省略
          一旦出错，才执行的错误处理代码: 提示错误, 记录日志
      }finally{
          无论是否出错，都必须执行的代码: 释放资源
      }
  Error: 封装错误信息的对象
            在发生错误时，自动创建
    err.name: 错误的名称
    err.message: 错误的提示信息
    js中包含6种错误: 
      SyntaxError: 语法错误
      ReferenceError: 引用错误 要用的东西没找到
      RangeError: 范围错误  专指参数超范围
      TypeError: 类型错误  错误的调用了对象的方法

      EvalError, URIError

   原则: 1. try中尽量少的包含语句
            2. 如果已经提前预知错误的类型，就用if...else...来代替try...catch
     何时: 今后只要处理无法提前预料的错误采用try...catch

   try...catch用于处理浏览器兼容性问题: 
     比如: Ajax : XMLHttpRequest

   抛出自定义错误: throw new Error("错误信息")

2. *****Function:
   函数对象: 专门封装一个函数定义的对象
   其实, js中一切函数都是引用类型的对象
   创建: 3种
      1. 以声明方式: 
          function 函数名(参数列表){函数体; return 返回值}
          会被声明提前！
          何时: 首选
          声明提前(hoist): 在程序开始执行前
                                    先将所有var声明的变量和function声明的函数提前到当前作用域的顶部，集中创建。
                                    赋值留在原地
      2. 函数直接量:
　　　var 函数名=function(参数列表){函数体; return 返回值}
          不会被声明提前
          何时: 不希望被声明提前时
      3. 用new: 
          var 函数名=new Function("参数1","参数2",...,"函数体")
          何时: 参数或函数体可能动态生成时
                   底层框架使用

      鄙视题: function compare(a,b){return a-b;}
                  var compare=function(a,b){return a-b;}
	var compare=new Function("a","b","return a-b");

   重载(overload): 相同函数名，不同参数列表的多个函数，在调用时，可根据传入参数的不同，自动选择对应的函数执行。
   为什么: 减少API的数量，减轻调用者的负担
   何时: 今后一项任务，只是根据传入参数的不同，执行不同的操作时，就用重载。
   如何:
     问题:  js的语法不支持重载,因为js中不允许同时存在多个同名函数。
     解决: 
       arguments: 每个函数内自动创建的
                           自动接收所有传入函数的参数值的
                           类数组对象――长的像数组的对象
                              vs 数组: 相同: 1. 下标访问每个元素
                                                    2. length属性记录元素个数
                                                    3. 用for 遍历
                                         不同: 不是数组类型
                                                  不能使用数组API
           
   匿名函数: 
     什么是:  函数创建时没有被任何变量引用的
     为什么:  节约内存
     何时: 如果一个函数只用一次，不会重用
         1. 所有回调函数，几乎都要用匿名
         2. 匿名函数自调: 创建一个函数，立刻调用，调用后立刻释放。
            主要目的: 为了定义一个临时函数作用域，避免全局污染

   作用域(scope): 一个变量的使用范围
               其实，作用域是一个对象，所有变量都保存在各自的作用域对象中。
       函数的生命周期: 
          程序开始执行时: 
              创建执行环境栈(ECS):
	依次保存正在调用的函数的执行环境 的数组 
              执行浏览器主程序(main): 
              创建window对象作为全局作用域对象
          定义函数时:
              在window中添加全局变量，函数名为变量名
              创建函数对象，封装函数的定义
              函数名变量引用函数对象
              函数对象中有一个scope属性引用函数创建时的作用域对象
          调用函数时:
             在ECS中压入正在调用的函数的执行环境
             创建本次函数调用使用的函数作用域对象(活动对象AO)
             本次函数调用的EC引用着AO
             在AO中定义parent属性，引用函数的scope指定的作用域对象。
             在AO中添加局部变量的定义
             变量使用的顺序: 
                 先用局部的，如果没有，才去全局找
          函数调用后: 
             将本次函数调用的EC出栈！
             导致本次函数调用的函数作用域(AO)对象释放
             导致局部变量一同释放
  
   作用域链(scope chain): 
      在函数调用时
      由各级作用域对象逐级引用形成的链式结构
      作用域链控制着变量的使用顺序
           先用局部的，如果没有，才去全局找



